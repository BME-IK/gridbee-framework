package gridbee.core.work;

import gridbee.core.iface.Worker;
import haxe.Log;
import js.Dom;
import js.Lib;
import gridbee.core.work.hxjson2.JSON;
import gridbee.core.iface.Worker;

/**
 * ...
 * @author Kalmi
 */


/*
 * NaClWorker is wrapper around NaCl that makes it act like a WebWorker.
 * 
 * Usage:
 *   Use it just like you would use a WebWorker,
 *   and it will transparently JSON encode/decode
 *   communcation between your Haxe code and the NaCl module.
 * 
 * Ports are not supported.
 * 
 * WARNING: The NaClWorker uses haxe's getters and setters, which don't get translated into Javascript as such.
 *          You should not use this from Javascipt, only from Javascript generated by Haxe.
 *          It would work to some extent when used from Javascript not generated by Haxe,
 *          but errors and messages could get lost in edge cases,
 * 	        such as errors occuring while loading NaCl modules,
 *          which would result in your code not getting notified of the crash
 *          and your code believing that NaCl is loading forever...
 */
class NaClWorker extends NaClWorker_StringOnly, implements Worker
{
	
	public function setOnerror(func : ErrorEvent -> Void) : Void
	{
		onerror = func;
	}
	
	public function setOnmessage(func : MessageEvent -> Void) : Void
	{
		onmessage = func;
	}
  
	public static function isSupported():Bool {
		return NaClWorker_StringOnly.isSupported();
	}
  
	private override function _onmessage(evt: MessageEvent) : Void {	
		Log.trace("_onmessage JSON wrapper called with " + evt.data);
		try{
			evt.data = JSON.decode(evt.data);  
		}catch (unknown : Dynamic) {
			var errorEvent : ErrorEvent = untyped __js__('new ErrorEvent()'); //converting this to String says [Object], why?
			errorEvent.message = "Got invalid JSON from NaCl. NaCl termined.\n";
			onerror(errorEvent);
			terminate();
			return;
		}
		super._onmessage(evt);
	}
  
	public override function postMessage(message:Dynamic) { 
		Log.trace("postMessage JSON wrapper called with " + message);    
		message = JSON.encode(message); //FIXME: error handling
		super.postMessage(message);
	}
}


private class NaClWorker_StringOnly implements EventTarget
{
	var naclElement : Dynamic;
		
	public function addEventListener(type : String, listener : Dynamic, useCapture : Bool = false) : Void {
		naclElement.addEventListener(type, listener, useCapture);
	}	
	public function removeEventListener(type : String, listener : Dynamic, useCapture : Bool = false) : Void {
		naclElement.removeEventListener(type, listener, useCapture);
	}	
	public function dispatchEvent(event : Event) : Bool {
		return naclElement.dispatchEvent(event);		
	}
	
	
	private function _onprogress(evt : ProgressEvent) : Void {
		Log.trace(evt.type);
	}
	
	private function _onabort(evt : ProgressEvent) : Void {
		//Never experienced irl
    var errorEvent : ErrorEvent = untyped __js__('new ErrorEvent()'); //converting this to String says [Object], why?
    errorEvent.message = "NaCl aborted";
    onerror(errorEvent);
	}
	
	private function _oncrash(evt : ProgressEvent) : Void {
		var errorEvent : ErrorEvent = untyped __js__('new ErrorEvent()'); //converting this to String says [Object], why?
    errorEvent.message = "NaCl module crashed";
    onerror(errorEvent);
	}
	
	
	/* onerror(ErrorEvent):Void;
	 * We queue the errors coming from NaCl until the user of the class assigns something to onerror.
	 * This is truly neccesary, because otherwise errors from the Initial stages of NaCl initialization could get lost, such as:
	 * file not found, insufficient memory, etc...
	 * 
	 * (I could have avoided this by only starting the executing when onerror has already been set, but I wanted this class to act like a WebWorker.)
	 */	
	var onerrorQueue : List<ErrorEvent>; //Queue messages until user sets onerror
	public  var onerror (onerrorGetter , onerrorSetter): ErrorEvent -> Void; //This is what gets set by the user. Its setter sends the contents of its queue to it.
	private var onerrorTheRealOne : ErrorEvent -> Void; //The internal variable that gets set/read by the getter/setter.
	private function onerrorSetter(func : ErrorEvent -> Void) : ErrorEvent -> Void {		
		Log.trace("onerrorSetter called");
		if (func != null) {
			if (!onerrorQueue.isEmpty())
				Log.trace("  sending content of queue");
			var evt : ErrorEvent;
			while ((evt = onerrorQueue.pop()) != null) { 
				Log.trace("    sent");
				func(evt);			
			}
			this.onerrorTheRealOne = func;
		}		
		return func;
	}
	private function onerrorGetter(): ErrorEvent -> Void {
		return this.onerrorTheRealOne;
	}
	private function _onerror(origEvent : ProgressEvent) : Void {
		// yep, for some reason we get a ProgressEvent, but it doesn't really matter, becuase it is pretty empty.
		// we are going to create an ErrorEvent based on naclElement.lastError
		
		Log.trace("_onerror called");				
		
		var errorEvent : ErrorEvent = untyped __js__('new ErrorEvent()'); //converting this to String says [Object], why?
		errorEvent.message = naclElement.lastError;
		
		if (this.onerror != null) {
			Log.trace("  handing it off to onerror");
			this.onerror(errorEvent);
		}else {
			Log.trace("  queueing it");
			onerrorQueue.add(errorEvent);
		}
	}
	
	
	/* onmessage(MessageEvent):Void;
	 * We queue the messages coming from NaCl until the user of the class assigns something to onmessage.
	 * There is no known case where this is truly neccesary, because NaCl modules don't load that fast...
	 */	
	var onmessageQueue : List<MessageEvent>; //Queue messages until user sets onmessage
	public var onmessage (onmessageGetter , onmessageSetter): MessageEvent -> Void; //This is what gets set by the user. Its setter sends the contents of its queue to it.
	private var onmessageTheRealOne : MessageEvent -> Void; //The internal variable that gets set/read by the getter/setter.
	private function onmessageSetter(func : MessageEvent -> Void) : MessageEvent -> Void {		
		Log.trace("onmessageSetter called");
		if (func != null) {			
			if (!onmessageQueue.isEmpty())
				Log.trace("  sending content of queue");
			var evt : MessageEvent;
			while ((evt = onmessageQueue.pop()) != null) { 
				Log.trace("    sent");
				func(evt);
			}
			this.onmessageTheRealOne = func;
		}		
		return func;
	}
	private function onmessageGetter(): MessageEvent -> Void {
		return this.onmessageTheRealOne;
	}
	private function _onmessage(evt: MessageEvent) : Void {	
		Log.trace("_onmessage called");
		if (this.onmessage != null) {
			Log.trace("  handing it off to onmessage");
			this.onmessage(evt);
		}else {
			Log.trace("  queueing it");
			onmessageQueue.add(evt);
		}
	}
	
	
	private function _onload() : Void {
		this.isReady = true;
		
		//NaCl became ready -> Send queued messages
		var message : String;		
		while ((message = postMessageQueue.pop())!=null) { 
			naclElement.postMessage(message);			
		}
	}
	
	public var isReady(default, null) : Bool;		
	
	public static function isSupported():Bool {		
		var testNaclElement:Dynamic = js.Lib.document.createElement("embed");
		testNaclElement.setAttribute("type", "application/x-nacl");
		testNaclElement.setAttribute("width",0);
		testNaclElement.setAttribute("height",0);		
		js.Lib.document.body.appendChild(testNaclElement);	
		var isSupported : Bool = testNaclElement.postMessage ? true : false;
		js.Lib.document.body.removeChild(testNaclElement);
		return isSupported;	
	}
	
	//Support for NaCl should be checked with isSupported before trying to create a new instance
	public function new(filename : String) : Void {		
		this.isReady = false;		
		this.postMessageQueue = new List<String>();
		this.onmessageQueue = new List<MessageEvent>();
		this.onerrorQueue = new List<ErrorEvent>();
		this.naclElement = js.Lib.document.createElement("embed");		
		naclElement.setAttribute("width",0);
		naclElement.setAttribute("height",0);
		naclElement.setAttribute("src",filename);
		naclElement.setAttribute("type", "application/x-nacl");
		naclElement.addEventListener("progress", this._onprogress, false); //why???
		naclElement.addEventListener("message", this._onmessage, false);				
		naclElement.addEventListener("error", this._onerror, false);		
		naclElement.addEventListener("abort", this._onabort, false); //???		
		naclElement.addEventListener("crash", this._oncrash, false); //???
		naclElement.addEventListener("load", this._onload, false);		
		js.Lib.document.body.appendChild(naclElement); //This line will start to actually run it.		
	}
	
	// TODO?: messagePort
		
	var postMessageQueue : List<String>; //Queue messages until NaCl becomes ready
	public function postMessage(message : Dynamic /*This should actually be String...*/ ) : Void {   
		if (this.isReady) {			
			naclElement.postMessage(message);
		} else {
			postMessageQueue.add(message);
		}
	}
	
	public function terminate() : Void {    
		js.Lib.document.body.removeChild(naclElement);
	}
}